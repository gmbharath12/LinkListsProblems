This project demonstrates 2 ways to remove duplicates from an Unsorted linked list
i) Traverse the list from the head (or start) node. While traversing, compare each node with its next node. If data of next node is same as current node then delete the next node. Before we delete a node, we need to store next pointer of the node
    Time Complexity: O(n^2)

ii) We traverse the link list from head to end. For every newly encountered element, we check whether it is in the hash table: if yes, we remove it; otherwise we put it in the hash table.
    Time Complexity: O(n) on average (assuming that map table access time is O(1) on average).

iii) Another way is to use Merge Sort and remove duplicates in a link list
     Time Complexity: O(nlogn). Remember that time complexity to remove duplicates in a sorted link list is O(n). we just need to traverse the list only once. 
     From : GeeksForGeeks
     /* The function removes duplicates from a sorted list */
void removeDuplicates(struct node* head)
{
  /* Pointer to traverse the linked list */
  struct node* current = head;
 
  /* Pointer to store the next pointer of a node to be deleted*/
  struct node* next_next; 
   
  /* do nothing if the list is empty */
  if(current == NULL) 
     return; 
 
  /* Traverse the list till last node */
  while(current->next != NULL) 
  {
   /* Compare current node with next node */
    if(current->data == current->next->data) 
    {
       /*The sequence of steps is important*/              
      next_next = current->next->next;
      free(current->next);
      current->next = next_next;  
    }
    else /* This is tricky: only advance if no deletion */
    {
      current = current->next; 
    }
  }
}


Time complexity of Merge Sort : O(nlogn)

